// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: query.sql

package dbgen

import (
	"context"
	"database/sql"
)

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (
    description,
    title,
    created_by,
    updated_by,
    deleted_by,
    created_at,
    updated_at,
    deleted_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    NOW(),
    NOW(),
    NOW()
)
RETURNING id, description, title, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at
`

type CreateCategoryParams struct {
	Description sql.NullString
	Title       sql.NullString
	CreatedBy   int64
	UpdatedBy   int64
	DeletedBy   int64
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (*Category, error) {
	row := q.db.QueryRowContext(ctx, createCategory,
		arg.Description,
		arg.Title,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.DeletedBy,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Title,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const createDevice = `-- name: CreateDevice :one
INSERT INTO devices (
    device_token,
    platform,
    status,
    created_by,
    updated_by,
    deleted_by,
    created_at,
    updated_at,
    deleted_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    NOW(),
    NOW(),
    NOW()
)
RETURNING id, device_token, platform, status, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at
`

type CreateDeviceParams struct {
	DeviceToken sql.NullString
	Platform    sql.NullString
	Status      sql.NullString
	CreatedBy   int64
	UpdatedBy   int64
	DeletedBy   int64
}

func (q *Queries) CreateDevice(ctx context.Context, arg CreateDeviceParams) (*Device, error) {
	row := q.db.QueryRowContext(ctx, createDevice,
		arg.DeviceToken,
		arg.Platform,
		arg.Status,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.DeletedBy,
	)
	var i Device
	err := row.Scan(
		&i.ID,
		&i.DeviceToken,
		&i.Platform,
		&i.Status,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const createObject = `-- name: CreateObject :one
INSERT INTO objects (
    category_id,
    content,
    title,
    created_by,
    updated_by,
    deleted_by,
    created_at,
    updated_at,
    deleted_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    NOW(),
    NOW(),
    NOW()
)
RETURNING id, category_id, content, title, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at
`

type CreateObjectParams struct {
	CategoryID int64
	Content    sql.NullString
	Title      sql.NullString
	CreatedBy  int64
	UpdatedBy  int64
	DeletedBy  int64
}

func (q *Queries) CreateObject(ctx context.Context, arg CreateObjectParams) (*Object, error) {
	row := q.db.QueryRowContext(ctx, createObject,
		arg.CategoryID,
		arg.Content,
		arg.Title,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.DeletedBy,
	)
	var i Object
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Content,
		&i.Title,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    first_name,
    last_name,
    username,
    email,
    password_hashed,
    password_salt,
    status,
    created_by,
    updated_by,
    deleted_by,
    created_at,
    updated_at,
    deleted_at
) VALUES (
    $1, 
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    NOW(),
    NOW(),
    NOW()
)
RETURNING id, first_name, last_name, username, email, password_hashed, password_salt, status, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	FirstName      sql.NullString
	LastName       sql.NullString
	Username       string
	Email          sql.NullString
	PasswordHashed sql.NullString
	PasswordSalt   sql.NullString
	Status         sql.NullString
	CreatedBy      int64
	UpdatedBy      int64
	DeletedBy      int64
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (*User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.FirstName,
		arg.LastName,
		arg.Username,
		arg.Email,
		arg.PasswordHashed,
		arg.PasswordSalt,
		arg.Status,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.DeletedBy,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Email,
		&i.PasswordHashed,
		&i.PasswordSalt,
		&i.Status,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories
WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCategory, id)
	return err
}

const deleteDevice = `-- name: DeleteDevice :exec
DELETE FROM devices
WHERE id = $1
`

func (q *Queries) DeleteDevice(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDevice, id)
	return err
}

const deleteObject = `-- name: DeleteObject :exec
DELETE FROM objects
WHERE id = $1
`

func (q *Queries) DeleteObject(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteObject, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const findAllCategories = `-- name: FindAllCategories :many
SELECT id, description, title, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at FROM categories
ORDER BY created_at
`

func (q *Queries) FindAllCategories(ctx context.Context) ([]*Category, error) {
	rows, err := q.db.QueryContext(ctx, findAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Title,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeletedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllDevices = `-- name: FindAllDevices :many
SELECT id, device_token, platform, status, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at FROM devices
ORDER BY created_at
`

func (q *Queries) FindAllDevices(ctx context.Context) ([]*Device, error) {
	rows, err := q.db.QueryContext(ctx, findAllDevices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Device
	for rows.Next() {
		var i Device
		if err := rows.Scan(
			&i.ID,
			&i.DeviceToken,
			&i.Platform,
			&i.Status,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeletedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllObjects = `-- name: FindAllObjects :many
SELECT id, category_id, content, title, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at FROM objects
ORDER BY created_at
`

func (q *Queries) FindAllObjects(ctx context.Context) ([]*Object, error) {
	rows, err := q.db.QueryContext(ctx, findAllObjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Object
	for rows.Next() {
		var i Object
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Content,
			&i.Title,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeletedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllUsers = `-- name: FindAllUsers :many
SELECT id, first_name, last_name, username, email, password_hashed, password_salt, status, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at FROM users
ORDER BY created_at
`

func (q *Queries) FindAllUsers(ctx context.Context) ([]*User, error) {
	rows, err := q.db.QueryContext(ctx, findAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Email,
			&i.PasswordHashed,
			&i.PasswordSalt,
			&i.Status,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeletedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findCategoryById = `-- name: FindCategoryById :one
SELECT id, description, title, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at FROM categories
WHERE id = $1 LIMIT 1
`

// Categories
func (q *Queries) FindCategoryById(ctx context.Context, id int64) (*Category, error) {
	row := q.db.QueryRowContext(ctx, findCategoryById, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Title,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const findDeviceById = `-- name: FindDeviceById :one
SELECT id, device_token, platform, status, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at FROM devices
WHERE id = $1 LIMIT 1
`

// Devices
func (q *Queries) FindDeviceById(ctx context.Context, id int64) (*Device, error) {
	row := q.db.QueryRowContext(ctx, findDeviceById, id)
	var i Device
	err := row.Scan(
		&i.ID,
		&i.DeviceToken,
		&i.Platform,
		&i.Status,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const findObjectById = `-- name: FindObjectById :one
SELECT id, category_id, content, title, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at FROM objects
WHERE id = $1 LIMIT 1
`

// Objects
func (q *Queries) FindObjectById(ctx context.Context, id int64) (*Object, error) {
	row := q.db.QueryRowContext(ctx, findObjectById, id)
	var i Object
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Content,
		&i.Title,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, first_name, last_name, username, email, password_hashed, password_salt, status, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at FROM users
WHERE email LIKE '%' || $1 || '%' LIMIT 1
`

func (q *Queries) FindUserByEmail(ctx context.Context, dollar_1 sql.NullString) (*User, error) {
	row := q.db.QueryRowContext(ctx, findUserByEmail, dollar_1)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Email,
		&i.PasswordHashed,
		&i.PasswordSalt,
		&i.Status,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const findUserById = `-- name: FindUserById :one

SELECT id, first_name, last_name, username, email, password_hashed, password_salt, status, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at FROM users
WHERE id = $1 LIMIT 1
`

// Query
// users
func (q *Queries) FindUserById(ctx context.Context, id int64) (*User, error) {
	row := q.db.QueryRowContext(ctx, findUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Email,
		&i.PasswordHashed,
		&i.PasswordSalt,
		&i.Status,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const findUserByUsername = `-- name: FindUserByUsername :one
SELECT id, first_name, last_name, username, email, password_hashed, password_salt, status, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at FROM users
WHERE username LIKE '%' || $1 || '%' LIMIT 1
`

func (q *Queries) FindUserByUsername(ctx context.Context, dollar_1 sql.NullString) (*User, error) {
	row := q.db.QueryRowContext(ctx, findUserByUsername, dollar_1)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Email,
		&i.PasswordHashed,
		&i.PasswordSalt,
		&i.Status,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const findUsersByEmail = `-- name: FindUsersByEmail :many
SELECT id, first_name, last_name, username, email, password_hashed, password_salt, status, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at FROM users
WHERE email LIKE '%' || $1 || '%'
ORDER BY created_at
LIMIT $2
OFFSET $3
`

type FindUsersByEmailParams struct {
	Column1 sql.NullString
	Limit   int32
	Offset  int32
}

func (q *Queries) FindUsersByEmail(ctx context.Context, arg FindUsersByEmailParams) ([]*User, error) {
	rows, err := q.db.QueryContext(ctx, findUsersByEmail, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Email,
			&i.PasswordHashed,
			&i.PasswordSalt,
			&i.Status,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeletedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUsersByUsername = `-- name: FindUsersByUsername :many
SELECT id, first_name, last_name, username, email, password_hashed, password_salt, status, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at FROM users
WHERE username LIKE '%' || $1 || '%'
ORDER BY created_at
LIMIT $2
OFFSET $3
`

type FindUsersByUsernameParams struct {
	Column1 sql.NullString
	Limit   int32
	Offset  int32
}

func (q *Queries) FindUsersByUsername(ctx context.Context, arg FindUsersByUsernameParams) ([]*User, error) {
	rows, err := q.db.QueryContext(ctx, findUsersByUsername, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Email,
			&i.PasswordHashed,
			&i.PasswordSalt,
			&i.Status,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeletedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET
    description = $2,
    title = $3,
    updated_by = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, description, title, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at
`

type UpdateCategoryParams struct {
	ID          int64
	Description sql.NullString
	Title       sql.NullString
	UpdatedBy   int64
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (*Category, error) {
	row := q.db.QueryRowContext(ctx, updateCategory,
		arg.ID,
		arg.Description,
		arg.Title,
		arg.UpdatedBy,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Title,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateDevice = `-- name: UpdateDevice :one
UPDATE devices
SET
    device_token = $2,
    platform = $3,
    status = $4,
    updated_by = $5,
    updated_at = NOW()
WHERE id = $1
RETURNING id, device_token, platform, status, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at
`

type UpdateDeviceParams struct {
	ID          int64
	DeviceToken sql.NullString
	Platform    sql.NullString
	Status      sql.NullString
	UpdatedBy   int64
}

func (q *Queries) UpdateDevice(ctx context.Context, arg UpdateDeviceParams) (*Device, error) {
	row := q.db.QueryRowContext(ctx, updateDevice,
		arg.ID,
		arg.DeviceToken,
		arg.Platform,
		arg.Status,
		arg.UpdatedBy,
	)
	var i Device
	err := row.Scan(
		&i.ID,
		&i.DeviceToken,
		&i.Platform,
		&i.Status,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateObject = `-- name: UpdateObject :one
UPDATE objects
SET
    category_id = $2,
    content = $3,
    title = $4,
    updated_by = $5,
    updated_at = NOW()
WHERE id = $1
RETURNING id, category_id, content, title, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at
`

type UpdateObjectParams struct {
	ID         int64
	CategoryID int64
	Content    sql.NullString
	Title      sql.NullString
	UpdatedBy  int64
}

func (q *Queries) UpdateObject(ctx context.Context, arg UpdateObjectParams) (*Object, error) {
	row := q.db.QueryRowContext(ctx, updateObject,
		arg.ID,
		arg.CategoryID,
		arg.Content,
		arg.Title,
		arg.UpdatedBy,
	)
	var i Object
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Content,
		&i.Title,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET 
    first_name = $2,
    last_name = $3,
    username = $4,
    email = $5,
    password_hashed = $6,
    password_salt = $7,
    status = $8,
    updated_by = $9,
    updated_at = NOW()
WHERE id = $1
RETURNING id, first_name, last_name, username, email, password_hashed, password_salt, status, created_by, updated_by, deleted_by, created_at, updated_at, deleted_at
`

type UpdateUserParams struct {
	ID             int64
	FirstName      sql.NullString
	LastName       sql.NullString
	Username       string
	Email          sql.NullString
	PasswordHashed sql.NullString
	PasswordSalt   sql.NullString
	Status         sql.NullString
	UpdatedBy      int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (*User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Username,
		arg.Email,
		arg.PasswordHashed,
		arg.PasswordSalt,
		arg.Status,
		arg.UpdatedBy,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Email,
		&i.PasswordHashed,
		&i.PasswordSalt,
		&i.Status,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
